# 面向对象

## 1.java类及类的成员

### 1.1类和类的成员

#### 1.1.1什么是类？什么是对象

---



##### 	对象：什么是对象？

万事万物皆可以为对象，是所有事物的具体实例

##### 	类：

对象的抽象化，对事物的描述，通过new来创造对象

#### 1.2类的成员

---



##### 1.2.1属性（成员变量）：描述事物的数据部分

```
	对象属性（实例变量）：依赖对象存在而存在的，存储在堆中的GC区
		1.声明在类中，方法等结构外
		2.声明格式：权限修饰符 变量类型 变量名=变量值；
		3.有默认值
		4.随着对象的创建而加载，存在堆中的GC中
		5.通过“对象.变量名” “对象.方法名”使用
		
		
	
	类属性（类变量）：是被static修饰的，依赖类的存在而存在，存储在方法区当中
		1.声明在类中，方法等结构外
		2.声明格式：权限修饰符 static 变量类型 变量名 = 变量值；
		3.有默认值
		4.随着类的加载而加载，存在方法区中
		5.类的对象共有
		6通过“对象.变量名” “类名.方法名”使用
```

##### 1.2.2方法

```
		普通方法：
		A.声明格式：权限修饰符 返回值类型 方法名（数据类型 形参）{方法体}
			1.权限修饰符：public 缺省 protect private 
			2.返回值类型：
						void 
						具体返回值类型：a.基本数据类 b.引用数据类型
			3.方法名 ：遵循标识符的规则和规范，并且做到“见名思意”
            4.局部变量：没有权限修饰符、没有默认值、在调用方法时存在栈中
            			形参列表   方法体中声明变量
            5.方法体：
            		方法具体功能的实现
            		方法体中可以调用当前类中的属性、其他方法
		B.批注：属于对象，可以通过“对象.方法名”调用，可以直接调用同类中的静态方法、静态属性
		
	静态方法：
		A.声明格式：权限修饰符 static 返回值类型 方法名（数据类型 形参）{}
			1.权限修饰符：同普通方法
			2.返回值类型：同普通方法
			3.方法名：同普通方法
			4.局部变量：同普通方法
			5.方法体：同普通方法
					方法具体功能的实现
					方法体中可以调用当前类静态的属性、静态的方法
		B.属于类的，可以通过“类名.方法名”和“对象.方法名”调用，不能直接调用同类中非静态的方法和非静态的属性
	抽象方法：
		A.声明格式：权限修饰符 abstrat 返回值类型 方法名（数据类型 形参）{}
			1.权限修饰符：同普通方法
			2.返回值类型：同普通方法
			3.方法名：同普通方法
			4.局部变量：同普通方法
		B.存在于抽象类中或接口中，需要被抽象类的子类或接口的实现类重写
	
```

##### 1.2.3构造器

```
	1.声明格式：权限修饰符 类名（形参列表）{执行的内容}  权限修饰符不显示指定默认与类相同
	
	作用：
		创建类的对象
		成员变量的初始化
	
    2.说明
    	1.类中，一定会有构造器
    	2.如果类中没有显式的定义构造器，系统默认提供一个空参的构造器
    	3.如果类中没有显式的定义构造器，系统默认提供一个空参的构造器
    	4.如果显式的声明了构造器，系统将不再提供空参构造器
        
```

##### 1.2.4代码块

```
	1.静态代码块：
		a.声明格式：声明格式：static{执行的代码}
		b.作用：用来给类或对象初始化操作
		c.说明：
			*属于类的，随着类的加载而被加载，存在于静态域中
			*只能被加载一次
			*不能调用非静态的结构
			*如果声明多个静态代码块，则按照声明的先后顺序执行
	2.非静态代码块：	
		a.声明格式：{执行的代码}
		b.作用：用来给对象做初始化操作
		c.说明：
			*随着对象的创建而被执行
			*每创建一个对象，就被执行一次
			*可以调用当前类静态以及非静态的结构
			*如果声明多个非静态代码块，则按照声明的先后顺序执行
```

##### 1.2.5内部类

```
	1.声明：在类A内部声明类B（包括类A方法中），则类B就是内部类
	2.说明：
		a.可以调用外部类的结构
		b.可以有权限修饰符
		c.可以被static、final、abstract修饰
		d.可以被继承
		e.可以声明属性、方法、构造器等
	3.使用：
		a.创建成员内部对象
			创建静态成员内部对象：new 外部类名.内部类名（）；
			创建非静态成员的内部类对象：new 外部类名（）.new 内部类名（）
		b.调用外部类结构 外部类类名.this.结构名
		c.局部内部类的使用	通过方法返回接口、抽象类的实例
```







## 2.三大特性

### 2.1封装性

#### 	2.1.1狭义上的封装

```
将属性私有化（private），通过公共的set、get方法操作属性
```



#### 	2.1.2广义上的封装

```
通过四种权限修饰符对类、接口以及它们内部的成员设置权限
A.private
	可修饰结构
		a.属性
		b.方法
		c.构造器
		d.内部类
	修饰结构的使用范围：本类中
B.缺省
	可修饰结构
		a.属性
		b.方法
		c.构造器
		d.内部类
		*e.类、接口
	修饰结构的使用范围
		a.本类
		b.同包类
C.protected
	可修饰结构
		a.属性
		b.方法
		c.构造器
		d.内部类
	修饰结构的使用范围
		a.本类
		b.同包类
		c.不同包下的子类
D.public
	可修饰结构
		a.属性
		b.方法
		c.构造器
		e.内部类
		f.类、接口
	修饰结构的使用范围：同一工程下的所有类 
```



#### 	2.2.3封装性的具体体现

```java
A.单例模式：
	饿汉式：/**
 * 单例 : 只允许有一个对象
 * 
 * 饿汉式单例 : 加载类模板时创建对象, 适用于创建对象快速
 * 1) 防止测试类中new操作, 封装构造器
 * 2) 在内部创建唯一对象, 并用私有的静态属性的引用指向唯一对象, 同时就把对象创建出来
 * 3) 在类中再提供一个公共的静态方法, 用以获取唯一对象
 * 

 */
	class Singleton1 {
	
	private static Singleton1 only = new Singleton1();
	
	public static Singleton1 getInstance() {
		return only;
	}
	
	private Singleton1() { // 封装构造器
	}
}

	懒汉式：
	class Singleton2 {
	
	private static Singleton2 only; // 初值为null
	
	public static Singleton2 getInstance() {
		if (only == null) {
			only = new Singleton2();
		}
		return only;
	}
	
	private Singleton2() {
	}
}
B.枚举类：
	enum定义枚举类要点
	1、私有化类构造器
	2、可以提供类的属性，声明为private final的
	3、在类的内部创建可数多个类的对象，创建对象时仅提供对象标识符即可；如果构造器时空参的，对象后的"()"可以省略，如果构造器不是空参的则不可以省略；对象之间用","隔开，最后一个对象后用";"
	4、各对象后可以使用"{}"，在"{}"中可以重写枚举类实现接口的抽象方法。该方式可以实现各对象分别重写接口中抽象方法的效果
```



### 2.2继承性

```
继承性
	1.格式
		class SubClass extends SuperClass
	2.作用
		子类通过继承父类，在本类不定义的情况下可以获取到父类的属性、结构等
	3.特征
		Java中的继承是单继承，一个子类只能有一个直接父类
		对于父类中私有的（private）的结构，子类不可以直接使用，但是子类获取到了父类中私有的结构
	4.意义
		减少代码的冗余，提高代码的复用性
		提高代码的可拓展性
		为多态打下基础
```



### 2.3多态性

#### 2.3.1什么是多态

```
同一事物的多种形态
子类对象的多种父类形态, 父类引用指向多种子类对象
```



#### 2.3.2多态的体现

##### 2.3.2.1狭义上的多态

```
父类引用指向子类对象
	前提
		有继承关系
		有方法的重写
	规则
		“编译看左边，运行看右边”
		只适用于方法，不适用于属性		
```



##### 2.3.2.2广义上的多态

```
A.父类引用指向子类对象
B.类中方法的重现与重载
	1.重写(override)
		a.前提
			存在继承关系（父子类中）
		b.规则
			子类重写方法与父类被重写方法的方法名、参数列表均相同
			子类重写方法的权限不小于父类被重写方法的权限
			子类重写方法的返回值类不大于父类被重写方法的返回值类型
			父类被重写方法的返回值类型如果是基本类型，子类重写方法的返回值类型必须与父类被重写方法的返回值类型相同
			子类重写方法抛出的异常不大于父类被重写方法抛出的异常
			子类重写方法与父类被重写的方法应同时为static或者非static的
	2.重载(overload)
		a.前提
			在同一个类中，多个方法之间
		b.规则
			方法名相同
			参数列表不同		
```



#### 2.3.3多态的应用

```
A.jdbc
B.多态数组
C.多态参数方法
```







## 3.关键字

```
package
	含义
		在Java中表示包
	声明格式
		package xxx.yyy.zzz;
	作用
		将不同的类放在不同的包下，方便对类的管理
	说明
		package声明应放在程序的首行
		应满足标识符的规则和规范：包名全部小写
		包名“.”一次代表一层目录结构
```



```
import
	作用
		在使用不同包中的类或接口时，可以通过使用inport关键字导入其他包中的类或接口
	使用格式
		import 包名.类名
	说明
		import语句要声明在package语句与源程序之前
		java.lang包下的类可以不用import语句导入
		如果需要导入某一包下的全部类和接口，声明格式为：import 报名.*
		如果需要导入多个类、接口，只需并列声明即可
		如果在一个类中，导入了两个不同包下同名的类，至少有一个调用时需使用全名
		利用import static 可以导入指定包下的静态结构
```



```
this
	含义
		表示类的当前对象
	使用
		this.属性名
		this.方法名(形参列表)
		this(形参列表)
	说明
		“this.属性名”表示调用类当前对象的属性；通常可以省略“this.”，在方法或构造器中，如果局部变量变量名与类的属性名相同则不可以省略
		“this.方法名(形参列表)”表示调用类当前对象的方法；通常省略“this.”
		“this(形参列表)”表示调用类的构造器；其只能声明在类构造器的首行；构造器不能利用“this(形参列表)”的形式调用自己
```



```
super
	前提
		存在继承关系（父子类）
	含义
		表示父类
	使用
		super.属性名
		super.方法名(形参列表)
		super(形参列表)
	说明
		“super.属性名”表示调用父类的属性；通常省略“super.”，在子类中有和父类重名的属性并调用父类中的该属性时不可以省略
		“super.方法名(形参列表)”表示调用父类中的方法；通常省略“super.”，如果子类重写了父类中的方法并在子类中调用被重写的方法则不能省略
		“super(形参列表)”表示调用父类的构造器；其只能声明在类构造器的首行；在一个子类中，最多只能声明一个“super(形参列表)”形式的父类构造器；在一个构造器中“this(形参列表)”或者“super(形参列表)”不能同时出现；如果在子类中没有显式的“this(形参列表)”和“super(形参列表)”，系统默认提供“super()”
```



```
static
	修饰属性
		类变量
			见类以及类的成员-->类的成员-->属性-->类变量
	修饰方法
		静态方法
			见类以及类的成员-->类的成员-->方法-->静态方法
	修饰代码块
		静态代码块
			见类以及类的成员-->类的成员-->代码块-->静态代码块
	修饰内部类
		静态成员内部类
			见类以及类的成员-->类的成员-->内部类
```



```
final
	修饰类
		该类不能被继承
	修饰属性
		属性为常量
		命名遵循标识符规范：XXX_YYY_ZZZ
		赋值位置：显式赋值、代码块赋值、构造器赋值
	修饰方法
		该方法不能被重写
```



```
abstract
	修饰方法
		抽象方法
			见类以及类的成员-->类的成员-->方法-->抽象方法
	修饰类
		抽象类
			抽象类有构造器
			抽象类不能实例化，需要子类继承，重写抽象类的抽象方法
			抽象类可以没有抽象方法，但是有抽象方法的类一定是抽象类
```



```
interface
	接口
		在Java中，接口是与类并列的一种结构
		接口不能实例化，没有构造器
		接口定义了一套操作规范，通过让类实现接口的方式实现类功能的扩展
		接口中只能有全局常量
			由public static final修饰
			public staitc final 可以省略
		Java7以前，接口中只能有抽象方法
			由public abstract修饰
			public abstract可以省略
		Java8
			抽象方法
			静态方法
				实现类以及实现类的对象都不能调用
				调用方式
					接口.方法名(形参列表)
			default方法
				实现类的父类没有同名同参数的方法或者实现类仅实现了接口
					实现类的对象可以直接调用该default方法
				实现类的父类有同名同参数的方法
					实现类的对象调用该方法调用的是父类中的方法
				实现类实现了多个接口，且多个接口都有该方法
					实现类须重写该方法
		接口只能被实现类实现(implements)
			一个实现类可以实现多个接口
			实现类必须重写接口中的所有抽象方法
			如果实现类没有完全重写接口中的抽象方法，则实现类必须为抽象类
		接口继承接口
			使用extends关键字
			一个接口可以继承多个接口
```



```
implements
	使用情景
		实体类实现接口
		实体类实现接口1,接口2...
	使用格式
		interface A{}  class SubClass extends Aextends
	使用情景
		实体类继承实体类
		实体类继承抽象类
		抽象类继承实体类
		抽象类继承接口
		接口继承接口1,接口2...
	使用格式implements
	使用情景
		实体类实现接口
		实体类实现接口1,接口2...
	使用格式
		interface A{}  class SubClass extends A
		class SubClass extends SuperClass 
```



```
instanceof
	使用格式
		对象 instanceof 类名/接口名
	作用
		判断关键字左边对象是否是关键字右边类/接口的对象/实现类的对象，如果是返回true，如果不是返回false；在向下转型时，为了避免ClassCastException，利用instanceof关键字进行判断
	使用情景
		向下转型
			转型操作
				使用强制转换符:()
			转型成功的情况
				instanceof左边对象就是关键字右边类的对象
				instanceof左边对象所属的类是关键字右边类的子类
				instanceof左边对象所属的类是关键字右边接口的实现类
```

